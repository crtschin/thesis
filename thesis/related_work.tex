\subsection{Related work}
\textbf{AD Formalizations.} While there are proofs of forward-mode AD algorithms\cite{huot2020correctness}\cite{barthe2020versatility} and many more implementations\cite{Shaikha2019}\cite{Margossian2019ARO}, there have been relative few attempts at formalized proofs in proof assistant.
In 2002, M. Mayero did a formalized proof of an AD framework in \<Fortran> in \<Coq>\cite{Mayero:CorrectnessProofAD}.
Their minimal language example included assignments and sequences as language constructs, and excluded all forms of non-sequential control flow.
They also restricted the terms in their language to first order types.

\textbf{Programming Language Metatheory.} Much meta-theoretical research has been done on encoding programming languages in proof assistants\cite{Aydemir2005}.
Examples include the weak higher-order abstract syntax approach worked out in Coq by Despeyroux, et al.\cite{10.1007/BFb0014049}, which shallowly embeds abstractions as functions $abs : (var \to tm) \to tm$.
The parametric HOAS variant by Chlipala\cite{10.1145/1411204.1411226}, is an interesting polymorphic generalization of this technique as it, like the strongly-typed terms representation used in this thesis, avoids the problems of alpha-conversion and capture avoidance while still being somewhat user-friendly.
The locally nameless approach introduced by many various authors\cite{McKinna_Pollack_1997}\cite{10.1007/3-540-57826-9_152}\cite{10.1145/1017472.1017477} takes a hybrid approach and preserves names for free variables while using the De-Bruijn representation for bound variables.

\textbf{Forward-Mode AD.} Forward-mode AD has been described for imperative languages very early on by Wengert\cite{10.1145/355586.364791}, who made use of a source code transformation.
The earliest found description of an approach for forward-mode AD on functional languages on first-order terms is by Karczmarczuk\cite{Karczmarczuk98functionaldifferentiation}.
Siskind and Pearlmutter presented a "nestable" variant of a forward-mode AD algorithm using the dual numbers representation.
This same algorithm is used in the library DiffSharp\cite{Baydin2015AutomaticDI}.
A nearly identical variation, implemented in Haskell, is given by Elliott\cite{Elliott2009-beautiful-differentiation}.

\textbf{Reverse-Mode AD.} There are many interpretations of reverse mode AD on functional languages.
The most well-known of which is the one by Pearlmutter and Siskind\cite{PearlmutterSiskind2008}, which makes use of non-local program transformations as a primitive derivative calculating operation.
This is also implemented in DiffSharp and the optimizing compiler Stalingrad\fancyfootnote{https://github.com/Functional-AutoDiff/STALINGRAD}.
An alternative is the approach by Wang et al. using delimited continuations\cite{ShiftReset:Backprop}, implemented in Lantern\fancyfootnote{https://github.com/feiwang3311/Lantern}.
Elliott gave a principled approach to reverse-mode AD from the perspective of category theory\cite{Elliott-2018-ad-icfp}.

% \cite{ShiftReset:Backprop}\cite{Brunel2020BackpropagationIT}\cite{PearlmutterSiskind2008}
% Advancements in the understanding of both forward-mode AD algorithms and meta-theoretical proof techniques have supplied enough resources to be able to do a formal proof.

% Huot, Staton and \Vakar{} have proposed a continuation-based algorithm which mimic much of the same ideas as reverse-mode automatic differentiation\cite{huot2020correctness}.